1. for range 循环的时候会创建每个元素的副本，而不是元素的引用。

2. 在函数有多个返回值时，只要有一个返回值有命名，其他的也必须命名。如果有多个返回值必须加上括号()；如果只有一个返回值且命名也必须加上括号()。这里的第一个返回值有命名 sum，第二个没有命名，所以错误。

3. new(T) 会为 T 类型的新值分配已置零的内存空间，并返回地址（指针），即类型为 `*T`的值。换句话说就是，返回一个指针，该指针指向新分配的、类型为 T 的零值。适用于值类型，如数组、结构体等。make(T,args) 返回初始化之后的 T 类型的值，这个值并不是 T 类型的零值，也不是指针 `*T`，是经过初始化之后的 T 的引用。make() 只适用于 slice、map 和 channel.

4. append() 的第二个参数不能直接使用 slice，需使用 … 操作符，将一个切片追加到另一个切片上：append(s1,s2…)。或者直接跟上元素，形如：append(s1,1,2,3)。

5. 结构体只能比较是否相等，但是不能比较大小。相同类型的结构体才能够进行比较，结构体是否相同不但与属性类型有关，还与属性顺序相关。

6. ```go
   type MyInt1 int //类型定义
   type MyInt2 = int //类型别名
   ```
   
7. nil 只能赋值给指针、chan、func、interface、map 或 slice 类型的变量。

8. 一个包可以出现多个 init() 函数,一个源文件也可以包含多个 init() 函数。

9. 类型选择，类型选择的语法形如：i.(type)，其中 i 是接口，type 是固定关键字，需要注意的是，只有接口类型才可以使用类型选择。

10. 打印一个 map 中不存在的值时，返回元素类型的零值。

11. 在Go语言中，切片是引用类型，在函数中，修改切片元素可能会影响到原始数据。(数组不会)

12. Go语言中只有强制类型转换，没有隐式类型转换，因此两个不同类型的数值相加可能会编译报错。

13. `cap()` 函数用于返回一个切片、数组或通道的容量。

14. 除 map 不存在的键值对时，不会报错，相当于没有任何作用；获取不存在的减值对时，返回值类型对应的零值，所以返回 0。

15. %d表示输出十进制数字，+表示输出数值的符号。这里不表示取反。

16. 在嵌套结构体中，People 称为内部类型，Teacher 称为外部类型；通过嵌套，内部类型的属性、方法，可以为外部类型所有，就好像是外部类型自己的一样。此外，外部类型还可以定义自己的属性和方法，甚至可以定义与内部相同的方法，这样内部类型的方法就会被“屏蔽”。

17. `:=`只支持局部变量声明。

18. Go 语言中的字符串是只读的。使用可变参数定义的函数，因此可以使用 `...` 符号将一个切片直接传递给该函数。但是，需要注意的是，在传递切片时，需要在切片后添加 `...` 符号，以将切片转换为参数序列。

19. 切片的容量，即切片可以向后扩展的最大长度，它必须小于等于切片底层数组从切片的开始位置到结束位置的长度。

20. ```go
    var myMap map[string]int // 声明一个 map，但是未进行初始化，值为 nil
    myMap['a']=1 //panic: assignment to entry in nil map
    myMap = make(map[string]int) // 使用 make() 函数初始化，将其变为非 nil 值的 map
    myMap['a']=1 //√
    ```

21. 判断map中键是否存在的特殊写法:`value, ok := map[key]`

22. 当多值赋值时，`:=` 左边的变量无论声明与否都可以。 

23. ~~~go
    func increaseB() (r int) {
        defer func() {
            r++
        }()
        return r
    }
    //返回值为1；在 Go 中，return 语句并不是原子操作，它在底层的执行顺序是这样的：先计算返回值，然后将返回值赋值给调用函数栈中的返回值变量，最后执行 defer 语句和返回调用函数。
    ~~~

24. ~~~go
    func f3() (r int) {
        defer func(r int) {
            r = r + 5
        }(r)
        return 1
    }
    //返回1，两个r不是同一个
    ~~~

25. ~~~go
    type Person struct {
        age int
    }
    
    func main() {
        person := &Person{28}
    
        // 1. 
        defer fmt.Println(person.age)
    
        // 2.
        defer func(p *Person) {
            fmt.Println(p.age)
        }(person)  
    
        // 3.
        defer func() {
            fmt.Println(person.age)
        }()
    
        person.age = 29
    }//输出：29 29 28
    //1.person.age 此时是将 28 当做 defer 函数的参数，会把 28 缓存在栈中，等到最后执行该 defer 语句的时候取出，即输出 28；
    //2.defer 缓存的是结构体 Person{28} 的地址，最终 Person{28} 的 age 被重新赋值为 29，所以 defer 语句最后执行的时候，依靠缓存的地址取出的 age 便是 29，即输出 29；
    //3.闭包引用，输出 29；
    ~~~

26. 

